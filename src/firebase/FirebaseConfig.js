import firebase from 'firebase/app'
import 'firebase/firestore'
import 'firebase/auth'

const config = {
  apiKey: "AIzaSyBOGYlGjT_PewQGd5E4F_K8NvcxdCFSWy4",
  authDomain: "crwn-db-679c5.firebaseapp.com",
  projectId: "crwn-db-679c5",
  storageBucket: "crwn-db-679c5.appspot.com",
  messagingSenderId: "942699657184",
  appId: "1:942699657184:web:af29c5a1f61ef742195d85"
};

export const createUserProfileDocument = async (userAuth, additionalData) => {
  if(!userAuth) {
    return;
  }

  // this takes the userAuth object that is generated by firestore authentication table when a user signs in - looks in the user collections and uses the authenticated user id to search 
  const userRef = firestore.doc(`users/${userAuth.uid}`)
  const collectionRef = firestore.collection('users')
  
  // this will get the snapshot object of the user
  const snapShot = await userRef.get();
  const collectionSnapshot = await collectionRef.get()
  console.log({collection: collectionSnapshot.docs.map(doc => doc.data() )})
  
  if(!snapShot.exists) {
    // if snapshot doesnt exist - we use the user ref to create a new document object inside of our userRef - userRef.set - create a new document object using these properties on it and creating it inside our database
    const {displayName, email} = userAuth;
    const createdAt = new Date();

    try {
      // set is the create method 
      await userRef.set({
        displayName, 
        email, 
        createdAt, 
        ...additionalData
      })
    } catch (error) {
      console.log('error creating user', error.message);
    }
  }
  return userRef;
}


// converting our data to be ready for database migration
export const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {
  const collectionRef = firestore.collection(collectionKey);
  // firebase will auto make this collection ref for us if it doesnt exist - then creating the collection and documents inside of firestore
  // console.log(collectionRef)

  // loops through the array and batches the calls together 
  const batch = firestore.batch()
  objectsToAdd.forEach(obj => {
    // this will create a new document reference and generate a new id in firestore - make a new doc referebce object for each collection 
    const newDocRef = collectionRef.doc()
    console.log(newDocRef)
    batch.set(newDocRef, obj)
  })

  return await batch.commit();
}

// this will convert it back to a array format that can be mapped and used across our app - Before this, it is an array but it is of the doc type from our database, instead we need it to just be an array on its own, not a value of the doc property that firestore returns - we want to convert it to an object - THIS IS ALL ABOUT GOING INTO FIRESTORE AND GETTING THE ARRAY OF OBJECTS THAT ARE IN FIRESTORE, CONVERTING IT TO AN OBJECT WITH THE RIGHT PROPERTIES WE NEED FOR IT, THEN RETURNING IT WITH NOT ONLY THE PROPERTIES WE NEED (NAME, TITLE, ITEMS) BUT ALSO THE ROUTENAME PROPERTY THAT WE NO LONGER HAVE AND NEED TO CREATE - THEN WE CAN CONVERT IT BACK TO AN ARRAY WITH THE CORRECT OBJECTS INSIDE THROUGH OUR SELECTOR FUNCTION FOR OUR SHOP - THIS WILL REPRESENT THE FINAL OBJECT WE WANT FOR OUR APP
export const convertCollectionsSnapshotToMap = (collections) => {
  const transformedCollection = collections.docs.map(doc => {
    const { title, items } = doc.data();
    return {
      // encodeURI comes with js renderer - pass a string 
      routeName: encodeURI(title.toLowerCase()),
      // id is part of the doc object
      id: doc.id,
      title: title,
      items: items
    }
  })


  console.log(transformedCollection)

    // WE reduce down to our final object here - takes the collection object at our current iteration - so now the key will be the title of the collection and the value will be the object containing the neeed properties - so "hats": {collection}
  return transformedCollection.reduce((accumulator, collection) => {
    accumulator[collection.title.toLowerCase()] = collection
    return accumulator;
  }, {})
};

export const getCurrentUser = () => {
  return new Promise((resolve, reject)  => {
    const unsubscribe = auth.onAuthStateChanged(userAuth => {
      unsubscribe();
      resolve(userAuth)
    }, reject)
  })
}

firebase.initializeApp(config);

export const auth = firebase.auth();
export const firestore = firebase.firestore();

// renamed because we want to execute this in our saga
// const provider = new firebase.auth.GoogleAuthProvider();
// we are going to import our new googleProvider const inside of our user.sagas
export const googleProvider = new firebase.auth.GoogleAuthProvider();

googleProvider.setCustomParameters({
  prompt: 'select_account'
})

export const signInWithGoogle = () => auth.signInWithPopup(googleProvider);
export default firebase;